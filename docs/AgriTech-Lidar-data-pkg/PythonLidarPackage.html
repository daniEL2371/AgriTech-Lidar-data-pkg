<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>AgriTech-Lidar-data-pkg.PythonLidarPackage API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AgriTech-Lidar-data-pkg.PythonLidarPackage</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from lidar_fetch_data import Lidar_Data_Fetch
from boundaries import Boundaries
from shapely.geometry import box, Point, Polygon
from elevation_extractor import ElevationExtractor
import geopandas as gpd
import matplotlib.pyplot as plt
import pickle
import os
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import numpy as np
import subsample


from boundaries import Boundaries


PUBLIC_DATA_URL = &#34;https://s3-us-west-2.amazonaws.com/usgs-lidar-public/&#34;
cache_folder = &#34;./cache&#34;
metadata_path = &#34;./meta_data3.csv&#34;
metric_epsg = 32643

try:
    meta_data = pd.read_csv(metadata_path)
    meta_data[&#39;year&#39;] = meta_data[&#39;year&#39;].fillna(0)
    meta_data[&#39;year&#39;] = meta_data[&#39;year&#39;].astype(&#39;int&#39;)
except:
    print(&#34;Could not read a metadata file&#34;)


def read_obj(file_name):
    with open(f&#34;{cache_folder}/{file_name}.pkl&#34;, &#34;rb&#34;) as f:
        return pickle.load(f)


def write_obj(file_name, obj):
    if (not os.path.isdir(&#39;./cache&#39;)):
        os.mkdir(&#34;./cache/&#34;)

    with open(f&#34;{cache_folder}/{file_name}.pkl&#34;, &#34;wb&#34;) as f:
        pickle.dump(obj, f)


def get_cache_name_from_polygon(polygon: Polygon):
    &#34;&#34;&#34;This method generates a unique cache name by hashing a query polygon coordinate points

    Args:
        polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon

    Returns:
        str: a unique cache name for a query polygon
    &#34;&#34;&#34;
    x, y = polygon.exterior.coords.xy

    temp = &#34;&#34;
    for i, j in zip(list(x), list(y)):
        temp += f&#34;{i}_{j}&#34;

    hashed_name = hash(temp)

    if hashed_name &lt; 0:
        hashed_name = &#34;a&#34; + str(hashed_name)[1:]

    return hashed_name


def cache_fetched_data(file_name: str, obj):

    try:
        write_obj(str(file_name), obj)
    except:
        pass


class PythonLidarPackage:
    &#34;&#34;&#34;This is a class for fetching, manipulating, and visualizing point cloud data. The package will accept boundary polygons in shapely.geometry.Polygon, and a coordinate reference system (CRS) and return a python dictionary with all years of data available and a geopandas grid point file with elevations encoded in the requested CRS.
     The package will also provide an option to graphically display the returned elevation files as a 3D plot and 2D heatmap.
    &#34;&#34;&#34;

    def __init__(self, crs_epsg: int) -&gt; None:
        &#34;&#34;&#34;This method is used to instantiate the class. It takes a CRS EPSG value (i.e refer to https://epsg.io/) to use.

        Args:
            crs_epsg (int): an integer EPSG value of coordinate reference system
        &#34;&#34;&#34;

        self.epsg = crs_epsg
        self.fetcher = Lidar_Data_Fetch(PUBLIC_DATA_URL, epsg=crs_epsg)
        self.ee = ElevationExtractor(crs_epgs=crs_epsg)

    def __get_region_from_boundary(self, bounds: Boundaries) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;This method accepts a Boundaries object which defines xmin, ymin, xmax, ymax and returns a dataframe of regions containing the boundary provieded.

        Args:
            bounds (Boundaries): a Boundaries object which defines a bound in form of xmin, ymin, xmax, ymax

        Returns:
            geopandas.GeoDataFrame: a dataframe containing rows of region name, filename location and year of the could point dataset containing the boundary defined 
        &#34;&#34;&#34;
        filtered_df = meta_data.loc[
            (meta_data[&#39;xmin&#39;] &lt;= bounds.xmin)
            &amp; (meta_data[&#39;xmax&#39;] &gt;= bounds.xmax)
            &amp; (meta_data[&#39;ymin&#39;] &lt;= bounds.ymin)
            &amp; (meta_data[&#39;ymax&#39;] &gt;= bounds.ymax)
        ]
        return filtered_df[[&#34;filename&#34;, &#34;region&#34;, &#34;year&#34;]]

    def __get_regions(self, polygon: Polygon) -&gt; dict:
        &#34;&#34;&#34;This metods accepts a boundary polygon finds all region file names and years containing the boundary polygon.


        Args:
            polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon

        Returns:
            dict: a dictionary where the keys are year and the values are region file names for all region containg the boundary polygon.
        &#34;&#34;&#34;
        polygon_df = gpd.GeoDataFrame([polygon], columns=[&#39;geometry&#39;])

        polygon_df.set_crs(epsg=4326, inplace=True)
        polygon_df[&#39;geometry&#39;] = polygon_df[&#39;geometry&#39;].to_crs(
            epsg=3857)

        minx, miny, maxx, maxy = polygon_df[&#39;geometry&#39;][0].bounds

        bounds = Boundaries(miny, minx, maxy, maxx)

        filtred_df = self.__get_region_from_boundary(bounds)
        filenames = filtred_df[&#39;filename&#39;].to_list()
        years = filtred_df[&#39;year&#39;].to_list()

        filename_year = dict()

        for filename, year in zip(filenames, years):
            filename_year[year] = filename

        return filename_year

    def get_elevation_df(self, polygon: Polygon, from_cache=False, enforce_cache=False) -&gt; dict:
        &#34;&#34;&#34;This method accepts a boundary polygon and returns a Python dictionary with all years of data available and geopandas grid point file with elevations encoded in the requested CRS of this object. The requested CRS is provided in the class init step.

        Args:
            polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon
            from_cache (bool, optional): if this value is true, it will first look  the result from the local cache file based on the queried polygon boundary. Defaults to False.
            enforce_cache (bool, optional): if this value is true, the result is going to be cahced in local file. Defaults to False.

        Returns:
            dict: a Python dictionary where the keys area all years of data available  and values are  geopandas grid point file with elevations encoded in the requested CRS of this object
        &#34;&#34;&#34;

        result = dict()

        cache_file_name = get_cache_name_from_polygon(polygon)

        if (from_cache and os.path.isfile(cache_file_name)):
            return read_obj(cache_file_name)

        regions_year_dict = self.__get_regions(polygon)

        ind = 0

        for year in regions_year_dict:

            file_name = regions_year_dict[year]
            if year == 0:
                year = &#34;Unknown&#34;

            try:
                print(
                    f&#34;trying to Fetch elevation data for year {year} from file_name {file_name}...&#34;)

                data, output_epsg = self.fetcher.runPipeline(
                    file_name, polygon)
                df = self.ee.get_elevetion(data)
                result[year] = df
            except:
                pass
            ind += 1

        if enforce_cache:
            cache_fetched_data(cache_file_name, result)

        return result

    def save_elevation_geodata(self, df: gpd.GeoDataFrame,  file_name: str, save_format=&#34;shp&#34;):
        &#34;&#34;&#34;This method saves a geopandas dataframe containing elevation points.

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame to be saved, the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            file_name (str): the name of the file to be saved. 
            save_format (str, optional): the formats to be used to save the dataframe, two format options are supported, &#39;shp&#39; and &#39;geojson&#39;. Defaults to &#34;shp&#34;.
        &#34;&#34;&#34;

        #         polygon_df = gpd.GeoDataFrame([polygon], columns=[&#39;geometry&#39;])
        #         polygon_df.set_crs(epsg=self.epsg, inplace=True)

        if save_format == &#34;shp&#34;:
            df.to_file(f&#34;{file_name}.shp&#34;)

        elif save_format == &#34;geojson&#34;:
            df.to_file(f&#34;{file_name}.geojson&#34;, driver=&#39;GeoJSON&#39;)

        else:
            print(&#34;Unsupported format, geojson and shp are only supported formats&#34;)

    def get_heatmap_visulazation(self, df: gpd.GeoDataFrame, cmap=&#34;terrain&#34;) -&gt; None:
        &#34;&#34;&#34;Plots a 2D heat map for the cloud datapoints of geopandas dataframe using matplotlib

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            cmap (str, optional): color map for the heatmap (i.e refer to https://matplotlib.org/stable/gallery/color/colormap_reference.html). Defaults to &#34;terrain&#34;.
        &#34;&#34;&#34;

        fig, ax = plt.subplots(1, 1, figsize=(12, 10))

        df.plot(column=&#39;elevation&#39;, ax=ax, legend=True, cmap=cmap)
        plt.show()

    def get_3D_visualzation(self, df, s=0.01, color=&#34;blue&#34;):
        &#34;&#34;&#34;Plots a 3D terrain scatter plot for the cloud datapoints of geopandas dataframe using matplotlib

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            s (float, optional): S value. Defaults to 0.01.
            color (str, optional): color of the points. Defaults to &#34;blue&#34;.
        &#34;&#34;&#34;

        x = df.geometry.x
        y = df.geometry.y
        z = df.elevation

        points = np.vstack((x, y, z)).transpose()

        fig, ax = plt.subplots(1, 1, figsize=(12, 10))
        ax = plt.axes(projection=&#39;3d&#39;)
        ax.scatter(points[:, 0], points[:, 1],
                   points[:, 2],  s=0.01, color=&#34;blue&#34;)
        plt.show()

    def subsampling_interpolation(self, df: gpd.GeoDataFrame, resolution: int):
        &#34;&#34;&#34;This method  accepts a geopandas dataframe and a resoultion and implements sub-sampling methods for reducing point cloud data density using grid system.

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            resolution (int): The resolution defines the grid area (in meter square) which a single point represents. 

        Returns:
            geopandas.GeoDataFrame: a subsampled interpolated geopandas dataframe
        &#34;&#34;&#34;
        df_meter = df.copy()
        df_meter[&#39;geometry&#39;] = df_meter.geometry.to_crs(metric_epsg)
        df_meter = df_meter.set_crs(epsg=metric_epsg)

        subsample_df = subsample.grid_barycenter_sample(df_meter, resolution)
        print(f&#34;subsampled number of points {subsample_df.shape[0]}&#34;)
        return subsample_df

    def covert_crs(self, df: gpd.GeoDataFrame, crs_epgs: int) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;This method accepts a geopandas dataframe and a CRS and converts the dataframe to the provided coordinate reference system

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            crs_epgs (int): [description]

        Returns:
            geopandas.GeoDataFrame: an integer EPSG value of coordinate reference system, (i.e refer to https://epsg.io/)
        &#34;&#34;&#34;

        return self.ee.covert_crs(crs_epgs, df)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.cache_fetched_data"><code class="name flex">
<span>def <span class="ident">cache_fetched_data</span></span>(<span>file_name: str, obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_fetched_data(file_name: str, obj):

    try:
        write_obj(str(file_name), obj)
    except:
        pass</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.get_cache_name_from_polygon"><code class="name flex">
<span>def <span class="ident">get_cache_name_from_polygon</span></span>(<span>polygon: shapely.geometry.polygon.Polygon)</span>
</code></dt>
<dd>
<div class="desc"><p>This method generates a unique cache name by hashing a query polygon coordinate points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>shapely.geometry.Polygon object defining a boundary polygon</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>a unique cache name for a query polygon</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cache_name_from_polygon(polygon: Polygon):
    &#34;&#34;&#34;This method generates a unique cache name by hashing a query polygon coordinate points

    Args:
        polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon

    Returns:
        str: a unique cache name for a query polygon
    &#34;&#34;&#34;
    x, y = polygon.exterior.coords.xy

    temp = &#34;&#34;
    for i, j in zip(list(x), list(y)):
        temp += f&#34;{i}_{j}&#34;

    hashed_name = hash(temp)

    if hashed_name &lt; 0:
        hashed_name = &#34;a&#34; + str(hashed_name)[1:]

    return hashed_name</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.read_obj"><code class="name flex">
<span>def <span class="ident">read_obj</span></span>(<span>file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_obj(file_name):
    with open(f&#34;{cache_folder}/{file_name}.pkl&#34;, &#34;rb&#34;) as f:
        return pickle.load(f)</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.write_obj"><code class="name flex">
<span>def <span class="ident">write_obj</span></span>(<span>file_name, obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_obj(file_name, obj):
    if (not os.path.isdir(&#39;./cache&#39;)):
        os.mkdir(&#34;./cache/&#34;)

    with open(f&#34;{cache_folder}/{file_name}.pkl&#34;, &#34;wb&#34;) as f:
        pickle.dump(obj, f)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage"><code class="flex name class">
<span>class <span class="ident">PythonLidarPackage</span></span>
<span>(</span><span>crs_epsg: int)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a class for fetching, manipulating, and visualizing point cloud data. The package will accept boundary polygons in shapely.geometry.Polygon, and a coordinate reference system (CRS) and return a python dictionary with all years of data available and a geopandas grid point file with elevations encoded in the requested CRS.
The package will also provide an option to graphically display the returned elevation files as a 3D plot and 2D heatmap.</p>
<p>This method is used to instantiate the class. It takes a CRS EPSG value (i.e refer to <a href="https://epsg.io/">https://epsg.io/</a>) to use.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crs_epsg</code></strong> :&ensp;<code>int</code></dt>
<dd>an integer EPSG value of coordinate reference system</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PythonLidarPackage:
    &#34;&#34;&#34;This is a class for fetching, manipulating, and visualizing point cloud data. The package will accept boundary polygons in shapely.geometry.Polygon, and a coordinate reference system (CRS) and return a python dictionary with all years of data available and a geopandas grid point file with elevations encoded in the requested CRS.
     The package will also provide an option to graphically display the returned elevation files as a 3D plot and 2D heatmap.
    &#34;&#34;&#34;

    def __init__(self, crs_epsg: int) -&gt; None:
        &#34;&#34;&#34;This method is used to instantiate the class. It takes a CRS EPSG value (i.e refer to https://epsg.io/) to use.

        Args:
            crs_epsg (int): an integer EPSG value of coordinate reference system
        &#34;&#34;&#34;

        self.epsg = crs_epsg
        self.fetcher = Lidar_Data_Fetch(PUBLIC_DATA_URL, epsg=crs_epsg)
        self.ee = ElevationExtractor(crs_epgs=crs_epsg)

    def __get_region_from_boundary(self, bounds: Boundaries) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;This method accepts a Boundaries object which defines xmin, ymin, xmax, ymax and returns a dataframe of regions containing the boundary provieded.

        Args:
            bounds (Boundaries): a Boundaries object which defines a bound in form of xmin, ymin, xmax, ymax

        Returns:
            geopandas.GeoDataFrame: a dataframe containing rows of region name, filename location and year of the could point dataset containing the boundary defined 
        &#34;&#34;&#34;
        filtered_df = meta_data.loc[
            (meta_data[&#39;xmin&#39;] &lt;= bounds.xmin)
            &amp; (meta_data[&#39;xmax&#39;] &gt;= bounds.xmax)
            &amp; (meta_data[&#39;ymin&#39;] &lt;= bounds.ymin)
            &amp; (meta_data[&#39;ymax&#39;] &gt;= bounds.ymax)
        ]
        return filtered_df[[&#34;filename&#34;, &#34;region&#34;, &#34;year&#34;]]

    def __get_regions(self, polygon: Polygon) -&gt; dict:
        &#34;&#34;&#34;This metods accepts a boundary polygon finds all region file names and years containing the boundary polygon.


        Args:
            polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon

        Returns:
            dict: a dictionary where the keys are year and the values are region file names for all region containg the boundary polygon.
        &#34;&#34;&#34;
        polygon_df = gpd.GeoDataFrame([polygon], columns=[&#39;geometry&#39;])

        polygon_df.set_crs(epsg=4326, inplace=True)
        polygon_df[&#39;geometry&#39;] = polygon_df[&#39;geometry&#39;].to_crs(
            epsg=3857)

        minx, miny, maxx, maxy = polygon_df[&#39;geometry&#39;][0].bounds

        bounds = Boundaries(miny, minx, maxy, maxx)

        filtred_df = self.__get_region_from_boundary(bounds)
        filenames = filtred_df[&#39;filename&#39;].to_list()
        years = filtred_df[&#39;year&#39;].to_list()

        filename_year = dict()

        for filename, year in zip(filenames, years):
            filename_year[year] = filename

        return filename_year

    def get_elevation_df(self, polygon: Polygon, from_cache=False, enforce_cache=False) -&gt; dict:
        &#34;&#34;&#34;This method accepts a boundary polygon and returns a Python dictionary with all years of data available and geopandas grid point file with elevations encoded in the requested CRS of this object. The requested CRS is provided in the class init step.

        Args:
            polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon
            from_cache (bool, optional): if this value is true, it will first look  the result from the local cache file based on the queried polygon boundary. Defaults to False.
            enforce_cache (bool, optional): if this value is true, the result is going to be cahced in local file. Defaults to False.

        Returns:
            dict: a Python dictionary where the keys area all years of data available  and values are  geopandas grid point file with elevations encoded in the requested CRS of this object
        &#34;&#34;&#34;

        result = dict()

        cache_file_name = get_cache_name_from_polygon(polygon)

        if (from_cache and os.path.isfile(cache_file_name)):
            return read_obj(cache_file_name)

        regions_year_dict = self.__get_regions(polygon)

        ind = 0

        for year in regions_year_dict:

            file_name = regions_year_dict[year]
            if year == 0:
                year = &#34;Unknown&#34;

            try:
                print(
                    f&#34;trying to Fetch elevation data for year {year} from file_name {file_name}...&#34;)

                data, output_epsg = self.fetcher.runPipeline(
                    file_name, polygon)
                df = self.ee.get_elevetion(data)
                result[year] = df
            except:
                pass
            ind += 1

        if enforce_cache:
            cache_fetched_data(cache_file_name, result)

        return result

    def save_elevation_geodata(self, df: gpd.GeoDataFrame,  file_name: str, save_format=&#34;shp&#34;):
        &#34;&#34;&#34;This method saves a geopandas dataframe containing elevation points.

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame to be saved, the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            file_name (str): the name of the file to be saved. 
            save_format (str, optional): the formats to be used to save the dataframe, two format options are supported, &#39;shp&#39; and &#39;geojson&#39;. Defaults to &#34;shp&#34;.
        &#34;&#34;&#34;

        #         polygon_df = gpd.GeoDataFrame([polygon], columns=[&#39;geometry&#39;])
        #         polygon_df.set_crs(epsg=self.epsg, inplace=True)

        if save_format == &#34;shp&#34;:
            df.to_file(f&#34;{file_name}.shp&#34;)

        elif save_format == &#34;geojson&#34;:
            df.to_file(f&#34;{file_name}.geojson&#34;, driver=&#39;GeoJSON&#39;)

        else:
            print(&#34;Unsupported format, geojson and shp are only supported formats&#34;)

    def get_heatmap_visulazation(self, df: gpd.GeoDataFrame, cmap=&#34;terrain&#34;) -&gt; None:
        &#34;&#34;&#34;Plots a 2D heat map for the cloud datapoints of geopandas dataframe using matplotlib

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            cmap (str, optional): color map for the heatmap (i.e refer to https://matplotlib.org/stable/gallery/color/colormap_reference.html). Defaults to &#34;terrain&#34;.
        &#34;&#34;&#34;

        fig, ax = plt.subplots(1, 1, figsize=(12, 10))

        df.plot(column=&#39;elevation&#39;, ax=ax, legend=True, cmap=cmap)
        plt.show()

    def get_3D_visualzation(self, df, s=0.01, color=&#34;blue&#34;):
        &#34;&#34;&#34;Plots a 3D terrain scatter plot for the cloud datapoints of geopandas dataframe using matplotlib

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            s (float, optional): S value. Defaults to 0.01.
            color (str, optional): color of the points. Defaults to &#34;blue&#34;.
        &#34;&#34;&#34;

        x = df.geometry.x
        y = df.geometry.y
        z = df.elevation

        points = np.vstack((x, y, z)).transpose()

        fig, ax = plt.subplots(1, 1, figsize=(12, 10))
        ax = plt.axes(projection=&#39;3d&#39;)
        ax.scatter(points[:, 0], points[:, 1],
                   points[:, 2],  s=0.01, color=&#34;blue&#34;)
        plt.show()

    def subsampling_interpolation(self, df: gpd.GeoDataFrame, resolution: int):
        &#34;&#34;&#34;This method  accepts a geopandas dataframe and a resoultion and implements sub-sampling methods for reducing point cloud data density using grid system.

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            resolution (int): The resolution defines the grid area (in meter square) which a single point represents. 

        Returns:
            geopandas.GeoDataFrame: a subsampled interpolated geopandas dataframe
        &#34;&#34;&#34;
        df_meter = df.copy()
        df_meter[&#39;geometry&#39;] = df_meter.geometry.to_crs(metric_epsg)
        df_meter = df_meter.set_crs(epsg=metric_epsg)

        subsample_df = subsample.grid_barycenter_sample(df_meter, resolution)
        print(f&#34;subsampled number of points {subsample_df.shape[0]}&#34;)
        return subsample_df

    def covert_crs(self, df: gpd.GeoDataFrame, crs_epgs: int) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;This method accepts a geopandas dataframe and a CRS and converts the dataframe to the provided coordinate reference system

        Args:
            df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
            crs_epgs (int): [description]

        Returns:
            geopandas.GeoDataFrame: an integer EPSG value of coordinate reference system, (i.e refer to https://epsg.io/)
        &#34;&#34;&#34;

        return self.ee.covert_crs(crs_epgs, df)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.covert_crs"><code class="name flex">
<span>def <span class="ident">covert_crs</span></span>(<span>self, df: geopandas.geodataframe.GeoDataFrame, crs_epgs: int) -> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This method accepts a geopandas dataframe and a CRS and converts the dataframe to the provided coordinate reference system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>geopandas.GeoDataFrame</code></dt>
<dd>a geopandas data frame,
the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.</dd>
<dt><strong><code>crs_epgs</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>an integer EPSG value of coordinate reference system, (i.e refer to <a href="https://epsg.io/">https://epsg.io/</a>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def covert_crs(self, df: gpd.GeoDataFrame, crs_epgs: int) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;This method accepts a geopandas dataframe and a CRS and converts the dataframe to the provided coordinate reference system

    Args:
        df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
        crs_epgs (int): [description]

    Returns:
        geopandas.GeoDataFrame: an integer EPSG value of coordinate reference system, (i.e refer to https://epsg.io/)
    &#34;&#34;&#34;

    return self.ee.covert_crs(crs_epgs, df)</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_3D_visualzation"><code class="name flex">
<span>def <span class="ident">get_3D_visualzation</span></span>(<span>self, df, s=0.01, color='blue')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a 3D terrain scatter plot for the cloud datapoints of geopandas dataframe using matplotlib</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>geopandas.GeoDataFrame</code></dt>
<dd>a geopandas data frame,
the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>S value. Defaults to 0.01.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>color of the points. Defaults to "blue".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_3D_visualzation(self, df, s=0.01, color=&#34;blue&#34;):
    &#34;&#34;&#34;Plots a 3D terrain scatter plot for the cloud datapoints of geopandas dataframe using matplotlib

    Args:
        df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
        s (float, optional): S value. Defaults to 0.01.
        color (str, optional): color of the points. Defaults to &#34;blue&#34;.
    &#34;&#34;&#34;

    x = df.geometry.x
    y = df.geometry.y
    z = df.elevation

    points = np.vstack((x, y, z)).transpose()

    fig, ax = plt.subplots(1, 1, figsize=(12, 10))
    ax = plt.axes(projection=&#39;3d&#39;)
    ax.scatter(points[:, 0], points[:, 1],
               points[:, 2],  s=0.01, color=&#34;blue&#34;)
    plt.show()</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_elevation_df"><code class="name flex">
<span>def <span class="ident">get_elevation_df</span></span>(<span>self, polygon: shapely.geometry.polygon.Polygon, from_cache=False, enforce_cache=False) -> dict</span>
</code></dt>
<dd>
<div class="desc"><p>This method accepts a boundary polygon and returns a Python dictionary with all years of data available and geopandas grid point file with elevations encoded in the requested CRS of this object. The requested CRS is provided in the class init step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>shapely.geometry.Polygon object defining a boundary polygon</dd>
<dt><strong><code>from_cache</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if this value is true, it will first look
the result from the local cache file based on the queried polygon boundary. Defaults to False.</dd>
<dt><strong><code>enforce_cache</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>if this value is true, the result is going to be cahced in local file. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>a Python dictionary where the keys area all years of data available
and values are
geopandas grid point file with elevations encoded in the requested CRS of this object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elevation_df(self, polygon: Polygon, from_cache=False, enforce_cache=False) -&gt; dict:
    &#34;&#34;&#34;This method accepts a boundary polygon and returns a Python dictionary with all years of data available and geopandas grid point file with elevations encoded in the requested CRS of this object. The requested CRS is provided in the class init step.

    Args:
        polygon (Polygon): shapely.geometry.Polygon object defining a boundary polygon
        from_cache (bool, optional): if this value is true, it will first look  the result from the local cache file based on the queried polygon boundary. Defaults to False.
        enforce_cache (bool, optional): if this value is true, the result is going to be cahced in local file. Defaults to False.

    Returns:
        dict: a Python dictionary where the keys area all years of data available  and values are  geopandas grid point file with elevations encoded in the requested CRS of this object
    &#34;&#34;&#34;

    result = dict()

    cache_file_name = get_cache_name_from_polygon(polygon)

    if (from_cache and os.path.isfile(cache_file_name)):
        return read_obj(cache_file_name)

    regions_year_dict = self.__get_regions(polygon)

    ind = 0

    for year in regions_year_dict:

        file_name = regions_year_dict[year]
        if year == 0:
            year = &#34;Unknown&#34;

        try:
            print(
                f&#34;trying to Fetch elevation data for year {year} from file_name {file_name}...&#34;)

            data, output_epsg = self.fetcher.runPipeline(
                file_name, polygon)
            df = self.ee.get_elevetion(data)
            result[year] = df
        except:
            pass
        ind += 1

    if enforce_cache:
        cache_fetched_data(cache_file_name, result)

    return result</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_heatmap_visulazation"><code class="name flex">
<span>def <span class="ident">get_heatmap_visulazation</span></span>(<span>self, df: geopandas.geodataframe.GeoDataFrame, cmap='terrain') -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a 2D heat map for the cloud datapoints of geopandas dataframe using matplotlib</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>geopandas.GeoDataFrame</code></dt>
<dd>a geopandas data frame,
the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>color map for the heatmap (i.e refer to <a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">https://matplotlib.org/stable/gallery/color/colormap_reference.html</a>). Defaults to "terrain".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_heatmap_visulazation(self, df: gpd.GeoDataFrame, cmap=&#34;terrain&#34;) -&gt; None:
    &#34;&#34;&#34;Plots a 2D heat map for the cloud datapoints of geopandas dataframe using matplotlib

    Args:
        df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
        cmap (str, optional): color map for the heatmap (i.e refer to https://matplotlib.org/stable/gallery/color/colormap_reference.html). Defaults to &#34;terrain&#34;.
    &#34;&#34;&#34;

    fig, ax = plt.subplots(1, 1, figsize=(12, 10))

    df.plot(column=&#39;elevation&#39;, ax=ax, legend=True, cmap=cmap)
    plt.show()</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.save_elevation_geodata"><code class="name flex">
<span>def <span class="ident">save_elevation_geodata</span></span>(<span>self, df: geopandas.geodataframe.GeoDataFrame, file_name: str, save_format='shp')</span>
</code></dt>
<dd>
<div class="desc"><p>This method saves a geopandas dataframe containing elevation points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>geopandas.GeoDataFrame</code></dt>
<dd>a geopandas data frame to be saved, the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the file to be saved. </dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>the formats to be used to save the dataframe, two format options are supported, 'shp' and 'geojson'. Defaults to "shp".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_elevation_geodata(self, df: gpd.GeoDataFrame,  file_name: str, save_format=&#34;shp&#34;):
    &#34;&#34;&#34;This method saves a geopandas dataframe containing elevation points.

    Args:
        df (geopandas.GeoDataFrame): a geopandas data frame to be saved, the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
        file_name (str): the name of the file to be saved. 
        save_format (str, optional): the formats to be used to save the dataframe, two format options are supported, &#39;shp&#39; and &#39;geojson&#39;. Defaults to &#34;shp&#34;.
    &#34;&#34;&#34;

    #         polygon_df = gpd.GeoDataFrame([polygon], columns=[&#39;geometry&#39;])
    #         polygon_df.set_crs(epsg=self.epsg, inplace=True)

    if save_format == &#34;shp&#34;:
        df.to_file(f&#34;{file_name}.shp&#34;)

    elif save_format == &#34;geojson&#34;:
        df.to_file(f&#34;{file_name}.geojson&#34;, driver=&#39;GeoJSON&#39;)

    else:
        print(&#34;Unsupported format, geojson and shp are only supported formats&#34;)</code></pre>
</details>
</dd>
<dt id="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.subsampling_interpolation"><code class="name flex">
<span>def <span class="ident">subsampling_interpolation</span></span>(<span>self, df: geopandas.geodataframe.GeoDataFrame, resolution: int)</span>
</code></dt>
<dd>
<div class="desc"><p>This method
accepts a geopandas dataframe and a resoultion and implements sub-sampling methods for reducing point cloud data density using grid system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>geopandas.GeoDataFrame</code></dt>
<dd>a geopandas data frame,
the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code></dt>
<dd>The resolution defines the grid area (in meter square) which a single point represents. </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geopandas.GeoDataFrame</code></dt>
<dd>a subsampled interpolated geopandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subsampling_interpolation(self, df: gpd.GeoDataFrame, resolution: int):
    &#34;&#34;&#34;This method  accepts a geopandas dataframe and a resoultion and implements sub-sampling methods for reducing point cloud data density using grid system.

    Args:
        df (geopandas.GeoDataFrame): a geopandas data frame,  the dataframe must contain int sereis cloumn called elevation and and a geometry point series column called geometry.
        resolution (int): The resolution defines the grid area (in meter square) which a single point represents. 

    Returns:
        geopandas.GeoDataFrame: a subsampled interpolated geopandas dataframe
    &#34;&#34;&#34;
    df_meter = df.copy()
    df_meter[&#39;geometry&#39;] = df_meter.geometry.to_crs(metric_epsg)
    df_meter = df_meter.set_crs(epsg=metric_epsg)

    subsample_df = subsample.grid_barycenter_sample(df_meter, resolution)
    print(f&#34;subsampled number of points {subsample_df.shape[0]}&#34;)
    return subsample_df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AgriTech-Lidar-data-pkg" href="index.html">AgriTech-Lidar-data-pkg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.cache_fetched_data" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.cache_fetched_data">cache_fetched_data</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.get_cache_name_from_polygon" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.get_cache_name_from_polygon">get_cache_name_from_polygon</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.read_obj" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.read_obj">read_obj</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.write_obj" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.write_obj">write_obj</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage">PythonLidarPackage</a></code></h4>
<ul class="">
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.covert_crs" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.covert_crs">covert_crs</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_3D_visualzation" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_3D_visualzation">get_3D_visualzation</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_elevation_df" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_elevation_df">get_elevation_df</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_heatmap_visulazation" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.get_heatmap_visulazation">get_heatmap_visulazation</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.save_elevation_geodata" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.save_elevation_geodata">save_elevation_geodata</a></code></li>
<li><code><a title="AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.subsampling_interpolation" href="#AgriTech-Lidar-data-pkg.PythonLidarPackage.PythonLidarPackage.subsampling_interpolation">subsampling_interpolation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>